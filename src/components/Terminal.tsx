'use client';

import React, { useState, useEffect, useRef, useCallback } from 'react';
import { Flex, Text } from '@/once-ui/components';
import styles from './Terminal.module.scss';

interface TerminalLine {
    type: 'command' | 'output' | 'error';
    text: string;
    timestamp?: Date;
}

interface TerminalProps {
    className?: string;
}

const Terminal: React.FC<TerminalProps> = ({ className }) => {
    const [lines, setLines] = useState<TerminalLine[]>([
        { type: 'output', text: 'Type "help" to see available commands.' },
    ]);
    const [currentInput, setCurrentInput] = useState('');
    const [commandHistory, setCommandHistory] = useState<string[]>([]);
    const [historyIndex, setHistoryIndex] = useState(-1);
    const [isTyping, setIsTyping] = useState(false);
    const [cursorPosition, setCursorPosition] = useState(0);
    const inputRef = useRef<HTMLInputElement>(null);
    const terminalRef = useRef<HTMLDivElement>(null);
    const hiddenSpanRef = useRef<HTMLSpanElement>(null);

    const commands = {
        help: {
            description: 'Show available commands',
            execute: () => [
                'Available commands:',
                '  help       - Show this help message',
                '  about      - Learn about Ayden',
                '  experience - View work experience',
                '  education  - View education',
                '  skills     - List technical skills',
                '  projects   - Show recent projects',
                '  contact    - Get contact information',
                '  resume     - Download resume',
                '  clear      - Clear terminal',
                '  ascii      - Show ASCII art',
                '  joke       - Tell a random joke',
                '  coffee     - Essential developer fuel',
                '  exit       - Close terminal',
                '',
                'Tip: Use arrow keys to navigate command history!',
            ]
        },
        about: {
            description: 'Learn about Ayden',
            execute: () => [
                'üëã Hi! I\'m Ayden Nguyen',
                '',
                'üéì 2nd year Computer Engineering Student at UBC',
                'üíª Passionate about backend development and embedded systems',
                'üöÄ Currently working as a Firmware Developer at UBC AeroDesign',
                'üè¢ Also working as a Middleware Administrator Assistant at BCLDB',
                '',
                'üå± I love exploring new technologies, cycling, and photography!',
                'üì∏ Fun fact: I completed a 600km cycling challenge at age 15!',
                '',
                'Currently focused on: C/C++, Python, TypeScript, and embedded systems.',
            ]
        },
        experience: {
            description: 'View work experience',
            execute: () => [
                'üíº Work Experience:',
                '',
                'üè¢ BC Liquor Distribution Branch (BCLDB)',
                '   üìÖ May 2025 - present',
                '   üîß Middleware Administrator Assistant',
                '   ‚Ä¢ Maintaining DEV and TEST infrastructure',
                '   ‚Ä¢ Administering Java deployments via Oracle Service Bus',
                '   ‚Ä¢ Managing PostgreSQL, Microsoft SQL, and Oracle SQL databases',
                '',
                '‚úàÔ∏è UBC AeroDesign - Firmware Developer',
                '   üìÖ June 2025 - present',
                '   ‚Ä¢ Developing flight control firmware for VTOL aircraft',
                '   ‚Ä¢ Implementing C code on STM32H7 for autonomous flight',
                '   ‚Ä¢ Working with PID, GPS, IMU, Airspeed sensors',
                '',
                '‚úàÔ∏è UBC AeroDesign - Power & Controls Lead',
                '   üìÖ Sept. 2023 - June 2025',
                '   ‚Ä¢ Led team of 6 students in electric propulsion design',
                '   ‚Ä¢ Achieved highest thrust-to-weight ratio in team history',
                '   ‚Ä¢ Designed PCBs for propulsion testing',
            ]
        },
        education: {
            description: 'View education',
            execute: () => [
                'üéì Education:',
                '',
                'üè´ University of British Columbia (UBC)',
                '   üìö Computer Engineering',
                '   üìÖ 2023 - 2027 (Expected)',
                '   üéØ Currently in 2nd year',
                '',
                'üìù Relevant Coursework:',
                '   ‚Ä¢ Data Structures and Algorithms',
                '   ‚Ä¢ Digital Logic Design',
                '   ‚Ä¢ Computer Architecture',
                '   ‚Ä¢ Software Engineering',
                '   ‚Ä¢ Differential Equations',
                '',
                'üèÜ Achievements:',
                '   ‚Ä¢ Dean\'s List',
                '   ‚Ä¢ Active in engineering design teams',
            ]
        },
        skills: {
            description: 'List technical skills',
            execute: () => [
                'üõ†Ô∏è Technical Skills:',
                '',
                'üíª Programming Languages:',
                '   ‚Ä¢ C/C++ (Advanced) - Embedded systems, firmware',
                '   ‚Ä¢ Python (Advanced) - Automation, data analysis',
                '   ‚Ä¢ TypeScript/JavaScript (Intermediate) - Web development',
                '   ‚Ä¢ Java (Intermediate) - Enterprise applications',
                '',
                'üîß Technologies & Tools:',
                '   ‚Ä¢ STM32 microcontrollers',
                '   ‚Ä¢ Arduino/ESP32',
                '   ‚Ä¢ Git/GitHub',
                '   ‚Ä¢ Linux/Unix systems',
                '   ‚Ä¢ Oracle Service Bus',
                '   ‚Ä¢ PostgreSQL, SQL Server, Oracle DB',
                '',
                '‚ö° Frameworks & Libraries:',
                '   ‚Ä¢ React.js/Next.js',
                '   ‚Ä¢ Node.js',
                '   ‚Ä¢ RESTful APIs',
                '',
                'üé® Other:',
                '   ‚Ä¢ PCB Design',
                '   ‚Ä¢ Photography',
                '   ‚Ä¢ Technical Documentation',
            ]
        },
        projects: {
            description: 'Show recent projects',
            execute: () => [
                'üöÄ Recent Projects:',
                '',
                '‚úàÔ∏è VTOL Electric Aircraft (UBC AeroDesign)',
                '   ‚Ä¢ Flight control firmware for autonomous navigation',
                '   ‚Ä¢ Sensor fusion with PID controllers',
                '   ‚Ä¢ Real-time telemetry systems',
                '',
                'üîã Electric Propulsion System',
                '   ‚Ä¢ High-performance electric aircraft design',
                '   ‚Ä¢ Custom PCB development for testing',
                '   ‚Ä¢ Arduino-based performance monitoring',
                '',
                'üåê Personal Portfolio Website',
                '   ‚Ä¢ Built with Next.js and TypeScript',
                '   ‚Ä¢ Modern UI with Once UI components',
                '   ‚Ä¢ Interactive terminal (you\'re using it now!)',
                '',
                'üìä Scheduler Automation (UBC CS)',
                '   ‚Ä¢ Python script for exam proctoring',
                '   ‚Ä¢ Automated scheduling based on availability',
                '',
                'Want to see more? Check out the projects section!',
            ]
        },
        contact: {
            description: 'Get contact information',
            execute: () => [
                'üìû Contact Information:',
                '',
                'üìß Email: aydennguyen604@gmail.com',
                'üíº LinkedIn: linkedin.com/in/aydennguyen/',
                'üêô GitHub: github.com/u759',
                'üìÑ Resume: Available for download',
                '',
                'üìç Location: Vancouver, BC, Canada',
                'üåê Website: You\'re on it!',
                '',
                'Feel free to reach out for collaboration opportunities!',
            ]
        },
        resume: {
            description: 'Download resume',
            execute: () => {
                // Trigger resume download
                if (typeof window !== 'undefined') {
                    const link = document.createElement('a');
                    link.href = '/files/resume.pdf';
                    link.download = 'Ayden_Nguyen_Resume.pdf';
                    link.click();
                }
                return [
                    'üìÑ Resume download initiated!',
                    '',
                    'If the download didn\'t start automatically,',
                    'you can find the resume link in the navigation.',
                ];
            }
        },
        clear: {
            description: 'Clear terminal',
            execute: () => {
                setLines([]);
                return [];
            }
        },
        ascii: {
            description: 'Show ASCII art',
            execute: () => [
                '    ___             __         ',
                '   /   | __  ______/ /__  ____ ',
                '  / /| |/ / / / __  / _ \\/ __ \\',
                ' / ___ / /_/ / /_/ /  __/ / / /',
                '/_/  |_\\__, /\\__,_/\\___/_/ /_/ ',
                '      /____/                   ',
                'üéØ Computer Engineering Student',
                'üöÄ Firmware Developer',
                'üíª Backend Enthusiast',
            ]
        },
        joke: {
            description: 'Tell a random joke',
            execute: () => {
                const jokes = [
                    [
                        'Why do programmers prefer dark mode?',
                        '',
                        'Because the light attracts bugs! üêõ'
                    ],
                    [
                        'How many programmers does it take to change a light bulb?',
                        '',
                        'None. That\'s a hardware problem! üí°'
                    ],
                    [
                        'Why do Java developers wear glasses?',
                        '',
                        'Because they can\'t C# ! üëì'
                    ],
                    [
                        'What\'s a programmer\'s favorite hangout place?',
                        '',
                        'Foo Bar! üç∫'
                    ],
                    [
                        'Why did the developer go broke?',
                        '',
                        'Because they used up all their cache! üí∏'
                    ],
                    [
                        'What do you call a programmer from Finland?',
                        '',
                        'Nerdic! üá´üáÆ'
                    ]
                ];
                return jokes[Math.floor(Math.random() * jokes.length)];
            }
        },
        coffee: {
            description: 'Essential developer fuel',
            execute: () => [
                '‚òï Coffee Status:',
                '',
                '‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê',
                '‚îÇ  ‚òï COFFEE LEVEL: ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë ‚îÇ',
                '‚îÇ     Status: CAFFEINATED     ‚îÇ',
                '‚îÇ     Mood: READY TO CODE     ‚îÇ',
                '‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò',
                '',
                'Debug mode: ENABLED ‚úÖ',
                'Productivity: MAXIMUM üöÄ',
                '',
                'Remember: Coffee first, code second! ‚òï‚Üíüíª',
            ]
        },
        exit: {
            description: 'Close terminal',
            execute: () => [
                'Thanks for exploring my terminal! üëã',
                '',
                'Feel free to browse the rest of my portfolio.',
                'Terminal session will close in 3 seconds...',
            ]
        }
    };

    const addLine = useCallback((line: TerminalLine) => {
        setLines(prev => [...prev, line]);
    }, []);

    const addLines = useCallback((newLines: string[], type: 'output' | 'error' = 'output') => {
        const terminalLines = newLines.map(text => ({ type, text, timestamp: new Date() }));
        setLines(prev => [...prev, ...terminalLines]);
    }, []);

    // Calculate cursor position based on input text width
    const updateCursorPosition = useCallback(() => {
        if (hiddenSpanRef.current && inputRef.current) {
            const cursorPos = inputRef.current.selectionStart || 0;
            const textBeforeCursor = currentInput.substring(0, cursorPos);
            hiddenSpanRef.current.textContent = textBeforeCursor;
            setCursorPosition(hiddenSpanRef.current.offsetWidth);
        }
    }, [currentInput]);

    // Update cursor position when input changes
    useEffect(() => {
        if (currentInput === '') {
            setCursorPosition(0);
        } else {
            updateCursorPosition();
        }
    }, [currentInput, updateCursorPosition]);

    const executeCommand = useCallback((command: string) => {
        const trimmedCommand = command.trim().toLowerCase();
        
        // Add command to history
        if (trimmedCommand && !commandHistory.includes(trimmedCommand)) {
            setCommandHistory(prev => [...prev, trimmedCommand]);
        }
        setHistoryIndex(-1);

        // Add command line
        addLine({ type: 'command', text: `$ ${command}`, timestamp: new Date() });

        if (!trimmedCommand) {
            return;
        }

        // Check if command exists
        if (trimmedCommand in commands) {
            setIsTyping(true);
            
            // Simulate typing delay for more realistic terminal feel
            setTimeout(() => {
                const result = commands[trimmedCommand as keyof typeof commands].execute();
                addLines(result);
                setIsTyping(false);
                
                // Special handling for exit command
                if (trimmedCommand === 'exit') {
                    setTimeout(() => {
                        setLines([
                            { type: 'output', text: 'Terminal session ended.' },
                            { type: 'output', text: 'Reload page to restart.' },
                        ]);
                    }, 3000);
                }
            }, Math.random() * 500 + 200); // Random delay between 200-700ms
        } else {
            addLines([
                `Command not found: ${trimmedCommand}`,
                'Type "help" to see available commands.',
            ], 'error');
        }
    }, [addLine, addLines, commandHistory]);

    const handleInputSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        if (currentInput.trim() && !isTyping) {
            executeCommand(currentInput);
            setCurrentInput('');
            setCursorPosition(0); // Reset cursor position when input is cleared
        }
    };

    const handleKeyDown = (e: React.KeyboardEvent) => {
        if (e.key === 'ArrowUp') {
            e.preventDefault();
            if (commandHistory.length > 0) {
                const newIndex = historyIndex === -1 ? commandHistory.length - 1 : Math.max(0, historyIndex - 1);
                setHistoryIndex(newIndex);
                setCurrentInput(commandHistory[newIndex]);
            }
        } else if (e.key === 'ArrowDown') {
            e.preventDefault();
            if (historyIndex !== -1) {
                const newIndex = historyIndex + 1;
                if (newIndex >= commandHistory.length) {
                    setHistoryIndex(-1);
                    setCurrentInput('');
                } else {
                    setHistoryIndex(newIndex);
                    setCurrentInput(commandHistory[newIndex]);
                }
            }
        }
        // Update cursor position after any key press
        requestAnimationFrame(updateCursorPosition);
    };

    // Auto-scroll to bottom when new lines are added
    useEffect(() => {
        if (terminalRef.current) {
            terminalRef.current.scrollTop = terminalRef.current.scrollHeight;
        }
    }, [lines]);

    // Focus input when terminal is clicked
    const handleTerminalClick = () => {
        if (inputRef.current && !isTyping) {
            inputRef.current.focus();
        }
    };

    return (
        <Flex
            direction="column"
            className={`${styles.terminal} ${className || ''}`}
            onClick={handleTerminalClick}
        >
            <div className={styles.header}>
                <div className={styles.controls}>
                    <div className={styles.dot} style={{ backgroundColor: '#ff5f57' }}></div>
                    <div className={styles.dot} style={{ backgroundColor: '#ffbd2e' }}></div>
                    <div className={styles.dot} style={{ backgroundColor: '#28ca42' }}></div>
                </div>
                <Text variant="body-default-s" className={styles.title}>
                    ayden@portfolio:~$
                </Text>
            </div>
            
            <div ref={terminalRef} className={styles.content}>
                {lines.map((line, index) => (
                    <div key={index} className={`${styles.line} ${styles[line.type]}`}>
                        <Text variant="code-default-s" className={styles.text}>
                            {line.text}
                        </Text>
                    </div>
                ))}
                
                {!isTyping && (
                    <form onSubmit={handleInputSubmit} className={styles.inputLine}>
                        <Text variant="code-default-s" className={styles.prompt}>
                            $&nbsp;
                        </Text>
                        <div className={styles.inputContainer}>
                            <input
                                ref={inputRef}
                                type="text"
                                value={currentInput}
                                onChange={(e) => {
                                    setCurrentInput(e.target.value);
                                    // Use requestAnimationFrame for better timing
                                    requestAnimationFrame(updateCursorPosition);
                                }}
                                onKeyDown={handleKeyDown}
                                onKeyUp={updateCursorPosition}
                                onClick={updateCursorPosition}
                                className={styles.input}
                                placeholder="Type a command..."
                                autoFocus
                                disabled={isTyping}
                            />
                            <span 
                                ref={hiddenSpanRef}
                                className={styles.hiddenSpan}
                                aria-hidden="true"
                            />
                            <span 
                                className={styles.cursor}
                                style={{ left: `${cursorPosition}px` }}
                            />
                        </div>
                    </form>
                )}
                
                {isTyping && (
                    <div className={styles.inputLine}>
                        <Text variant="code-default-s" className={styles.prompt}>
                            $&nbsp;
                        </Text>
                        <span className={styles.typing}>...</span>
                    </div>
                )}
            </div>
        </Flex>
    );
};

export default Terminal;
